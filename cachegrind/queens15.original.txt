--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, 16-way associative
Command:          ./cover_mrv
Data file:        cachegrind.out.28299
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw Bc Bcm Bi Bim
Thresholds:       0.1 100 100 100 100 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
             Ir  I1mr  ILmr             Dr   D1mr  DLmr             Dw  D1mw  DLmw             Bc           Bcm     Bi    Bim 
--------------------------------------------------------------------------------
369,872,665,115 3,756 1,978 80,982,006,118 17,284 8,108 24,432,743,697 4,543 3,185 52,460,775,829 4,617,658,791 78,713 15,806  PROGRAM TOTALS

--------------------------------------------------------------------------------
             Ir I1mr ILmr             Dr  D1mr  DLmr             Dw  D1mw DLmw             Bc           Bcm     Bi    Bim  file:function
--------------------------------------------------------------------------------
307,320,490,435   19   19 80,455,241,231   135     0 24,432,092,164   156    0 52,460,066,845 4,617,634,914      0      0  /home/ricbit/work/knuth/dlx/cover_mrv.cc:ExactCover::run()
 62,547,224,228    4    4    525,316,569     0     0              0     0    0              0             0      0      0  /usr/include/c++/8/bits/stl_vector.h:ExactCover::run()

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/bits/stl_vector.h
--------------------------------------------------------------------------------
            Ir I1mr ILmr          Dr D1mr DLmr    Dw D1mw DLmw    Bc Bcm Bi Bim 

-- line 88 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .        struct _Vector_impl
             .    .    .           .    .    .     .    .    .     .   .  .   .        : public _Tp_alloc_type
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	pointer _M_start;
             .    .    .           .    .    .     .    .    .     .   .  .   .  	pointer _M_finish;
             .    .    .           .    .    .     .    .    .     .   .  .   .  	pointer _M_end_of_storage;
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  	_Vector_impl()
           858    1    1           0    0    0   858    1    0     0   0  0   0  	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
             .    .    .           .    .    .     .    .    .     .   .  .   .  	{ }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
           867    2    2           0    0    0   867  105  104     0   0  0   0  	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
             .    .    .           .    .    .     .    .    .     .   .  .   .  	{ }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  #if __cplusplus >= 201103L
             .    .    .           .    .    .     .    .    .     .   .  .   .  	_Vector_impl(_Tp_alloc_type&& __a) noexcept
             .    .    .           .    .    .     .    .    .     .   .  .   .  	: _Tp_alloc_type(std::move(__a)),
         2,044    1    1           0    0    0 1,533  184  184     0   0  0   0  	  _M_start(), _M_finish(), _M_end_of_storage()
             .    .    .           .    .    .     .    .    .     .   .  .   .  	{ }
             .    .    .           .    .    .     .    .    .     .   .  .   .  #endif
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
             .    .    .           .    .    .     .    .    .     .   .  .   .  	{
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  std::swap(_M_start, __x._M_start);
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  std::swap(_M_finish, __x._M_finish);
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
-- line 114 ----------------------------------------
-- line 288 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .      public:
             .    .    .           .    .    .     .    .    .     .   .  .   .        _Vector_impl _M_impl;
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        pointer
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_allocate(size_t __n)
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         3,631    1    1           0    0    0     9    0    0   981   0  0   0  	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_deallocate(pointer __p, size_t __n)
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
         4,128    3    3          10    0    0     0    0    0 2,064  14  0   0  	if (__p)
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  _Tr::deallocate(_M_impl, __p, __n);
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .      private:
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_create_storage(size_t __n)
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
           581    0    0         294    0    0   287    0    0     0   0  0   0  	this->_M_impl._M_start = this->_M_allocate(__n);
           287    0    0           0    0    0   285    0    0     0   0  0   0  	this->_M_impl._M_finish = this->_M_impl._M_start;
           577    0    0           2    0    0   287    0    0     0   0  0   0  	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .      };
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .    /**
             .    .    .           .    .    .     .    .    .     .   .  .   .     *  @brief A standard container which offers fixed time access to
             .    .    .           .    .    .     .    .    .     .   .  .   .     *  individual elements in any order.
             .    .    .           .    .    .     .    .    .     .   .  .   .     *
             .    .    .           .    .    .     .    .    .     .   .  .   .     *  @ingroup sequences
-- line 321 ----------------------------------------
-- line 452 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @a __x  will not be copied
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  (i.e. capacity() == size() in the new %vector).
             .    .    .           .    .    .     .    .    .     .   .  .   .         *
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  The newly-created %vector uses a copy of the allocator object used
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  by @a __x (unless the allocator traits dictate a different object).
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
             .    .    .           .    .    .     .    .    .     .   .  .   .        vector(const vector& __x)
             .    .    .           .    .    .     .    .    .     .   .  .   .        : _Base(__x.size(),
            30    0    0          20    0    0    10    0    0     0   0  0   0  	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
           294    0    0          10    0    0   284    0    0     0   0  0   0  	this->_M_impl._M_finish =
           822    0    0         548    0    0   274    0    0     0   0  0   0  	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
             .    .    .           .    .    .     .    .    .     .   .  .   .  				      this->_M_impl._M_start,
             .    .    .           .    .    .     .    .    .     .   .  .   .  				      _M_get_Tp_allocator());
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  #if __cplusplus >= 201103L
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @brief  %Vector move constructor.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @param  __x  A %vector of identical element and allocator types.
-- line 471 ----------------------------------------
-- line 557 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .  #endif
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  The dtor only erases the elements, and note that if the
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  elements themselves are pointers, the pointed-to memory is
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  not touched in any way.  Managing the pointer is the user's
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  responsibility.
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
            10    2    2           0    0    0     8    0    0     0   0  0   0        ~vector() _GLIBCXX_NOEXCEPT
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
         2,169    2    2       2,169  109    0     0    0    0     0   0  0   0  	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
             .    .    .           .    .    .     .    .    .     .   .  .   .  		      _M_get_Tp_allocator());
             .    .    .           .    .    .     .    .    .     .   .  .   .  	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
             8    0    0           8    1    0     0    0    0     0   0  0   0        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @brief  %Vector assignment operator.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @param  __x  A %vector of identical element and allocator types.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  All the elements of @a __x are copied, but any unused capacity in
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @a __x will not be copied.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *
-- line 578 ----------------------------------------
-- line 797 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .        const_reverse_iterator
             .    .    .           .    .    .     .    .    .     .   .  .   .        crend() const noexcept
             .    .    .           .    .    .     .    .    .     .   .  .   .        { return const_reverse_iterator(begin()); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  #endif
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // [23.2.4.2] capacity
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**  Returns the number of elements in the %vector.  */
             .    .    .           .    .    .     .    .    .     .   .  .   .        size_type
           284    0    0           0    0    0   284    0    0     0   0  0   0        size() const _GLIBCXX_NOEXCEPT
        12,140    2    2       3,648  113    0     1    0    0     0   0  0   0        { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**  Returns the size() of the largest possible %vector.  */
             .    .    .           .    .    .     .    .    .     .   .  .   .        size_type
             .    .    .           .    .    .     .    .    .     .   .  .   .        max_size() const _GLIBCXX_NOEXCEPT
             .    .    .           .    .    .     .    .    .     .   .  .   .        { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  #if __cplusplus >= 201103L
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
-- line 814 ----------------------------------------
-- line 887 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .  			 - this->_M_impl._M_start); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  Returns true if the %vector is empty.  (Thus begin() would
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  equal end().)
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
             .    .    .           .    .    .     .    .    .     .   .  .   .        bool
             .    .    .           .    .    .     .    .    .     .   .  .   .        empty() const _GLIBCXX_NOEXCEPT
           284    0    0         284    0    0     0    0    0     0   0  0   0        { return begin() == end(); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @brief  Attempt to preallocate enough memory for specified number of
             .    .    .           .    .    .     .    .    .     .   .  .   .         *          elements.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @param  __n  Number of elements required.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @throw  std::length_error  If @a n exceeds @c max_size().
             .    .    .           .    .    .     .    .    .     .   .  .   .         *
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  This function attempts to reserve enough memory for the
-- line 903 ----------------------------------------
-- line 925 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  Note that data access with this operator is unchecked and
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  out_of_range lookups are not defined. (For checked lookups
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  see at().)
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
             .    .    .           .    .    .     .    .    .     .   .  .   .        reference
             .    .    .           .    .    .     .    .    .     .   .  .   .        operator[](size_type __n) _GLIBCXX_NOEXCEPT
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	__glibcxx_requires_subscript(__n);
62,547,231,418    6    6 525,317,961    0    0     0    0    0     0   0  0   0  	return *(this->_M_impl._M_start + __n);
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        /**
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @brief  Subscript access to the data contained in the %vector.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @param __n The index of the element for which data should be
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  accessed.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  @return  Read-only (constant) reference to data.
             .    .    .           .    .    .     .    .    .     .   .  .   .         *
-- line 941 ----------------------------------------
-- line 943 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  Note that data access with this operator is unchecked and
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  out_of_range lookups are not defined. (For checked lookups
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  see at().)
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
             .    .    .           .    .    .     .    .    .     .   .  .   .        const_reference
             .    .    .           .    .    .     .    .    .     .   .  .   .        operator[](size_type __n) const _GLIBCXX_NOEXCEPT
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	__glibcxx_requires_subscript(__n);
         7,908    2    2       3,760    0    0     0    0    0     0   0  0   0  	return *(this->_M_impl._M_start + __n);
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .      protected:
             .    .    .           .    .    .     .    .    .     .   .  .   .        /// Safety check used only from at().
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_range_check(size_type __n) const
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	if (__n >= this->size())
-- line 959 ----------------------------------------
-- line 1068 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  element at the end of the %vector and assigns the given data
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  to it.  Due to the nature of a %vector this operation can be
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  done in constant time if the %vector has preallocated space
             .    .    .           .    .    .     .    .    .     .   .  .   .         *  available.
             .    .    .           .    .    .     .    .    .     .   .  .   .         */
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        push_back(const value_type& __x)
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
         4,716    1    1       3,144    0    0     0    0    0 1,572 251  0   0  	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  {
             .    .    .           .    .    .     .    .    .     .   .  .   .  	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
             .    .    .           .    .    .     .    .    .     .   .  .   .  	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
             .    .    .           .    .    .     .    .    .     .   .  .   .  				     __x);
           595    0    0         595    0    0     0    0    0     0   0  0   0  	    ++this->_M_impl._M_finish;
             .    .    .           .    .    .     .    .    .     .   .  .   .  	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  }
             .    .    .           .    .    .     .    .    .     .   .  .   .  	else
         4,885    2    2          20    0    0   977    0    0     0   0  0   0  	  _M_realloc_insert(end(), __x);
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  #if __cplusplus >= 201103L
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        push_back(value_type&& __x)
             .    .    .           .    .    .     .    .    .     .   .  .   .        { emplace_back(std::move(__x)); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        template<typename... _Args>
-- line 1093 ----------------------------------------
-- line 1458 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Called by the second initialize_dispatch above
             .    .    .           .    .    .     .    .    .     .   .  .   .        template<typename _ForwardIterator>
             .    .    .           .    .    .     .    .    .     .   .  .   .  	void
             .    .    .           .    .    .     .    .    .     .   .  .   .  	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
             .    .    .           .    .    .     .    .    .     .   .  .   .  			    std::forward_iterator_tag)
             .    .    .           .    .    .     .    .    .     .   .  .   .  	{
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  const size_type __n = std::distance(__first, __last);
             2    0    0           0    0    0     2    0    0     0   0  0   0  	  this->_M_impl._M_start = this->_M_allocate(__n);
             4    0    0           0    0    0     2    0    0     0   0  0   0  	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
             2    0    0           0    0    0     2    1    0     0   0  0   0  	  this->_M_impl._M_finish =
             .    .    .           .    .    .     .    .    .     .   .  .   .  	    std::__uninitialized_copy_a(__first, __last,
             .    .    .           .    .    .     .    .    .     .   .  .   .  					this->_M_impl._M_start,
             .    .    .           .    .    .     .    .    .     .   .  .   .  					_M_get_Tp_allocator());
             .    .    .           .    .    .     .    .    .     .   .  .   .  	}
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Called by the first initialize_dispatch above and by the
             .    .    .           .    .    .     .    .    .     .   .  .   .        // vector(n,value,a) constructor.
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
-- line 1476 ----------------------------------------
-- line 1479 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .  	this->_M_impl._M_finish =
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
             .    .    .           .    .    .     .    .    .     .   .  .   .  					_M_get_Tp_allocator());
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .  #if __cplusplus >= 201103L
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Called by the vector(n) constructor.
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             4    0    0           2    0    0     1    0    0     0   0  0   0        _M_default_initialize(size_type __n)
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
             3    0    0           0    0    0     3    0    0     0   0  0   0  	this->_M_impl._M_finish =
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
             .    .    .           .    .    .     .    .    .     .   .  .   .  					   _M_get_Tp_allocator());
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  #endif
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Internal assign functions follow.  The *_aux functions do the actual
             .    .    .           .    .    .     .    .    .     .   .  .   .        // assignment work for the range versions.
             .    .    .           .    .    .     .    .    .     .   .  .   .  
-- line 1497 ----------------------------------------
-- line 1634 ----------------------------------------
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_emplace_aux(const_iterator __position, value_type&& __v)
             .    .    .           .    .    .     .    .    .     .   .  .   .        { return _M_insert_rval(__position, std::move(__v)); }
             .    .    .           .    .    .     .    .    .     .   .  .   .  #endif
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Called by _M_fill_insert, _M_insert_aux etc.
             .    .    .           .    .    .     .    .    .     .   .  .   .        size_type
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_check_len(size_type __n, const char* __s) const
             .    .    .           .    .    .     .    .    .     .   .  .   .        {
         1,964    1    1       1,954    0    0    10    0    0     0   0  0   0  	if (max_size() - size() < __n)
             .    .    .           .    .    .     .    .    .     .   .  .   .  	  __throw_length_error(__N(__s));
             .    .    .           .    .    .     .    .    .     .   .  .   .  
         3,652    2    2         977    0    0   987    0    0     0   0  0   0  	const size_type __len = size() + std::max(size(), __n);
         3,455    0    0           0    0    0     0    0    0 1,382 461  0   0  	return (__len < size() || __len > max_size()) ? max_size() : __len;
             .    .    .           .    .    .     .    .    .     .   .  .   .        }
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Internal erase functions follow.
             .    .    .           .    .    .     .    .    .     .   .  .   .  
             .    .    .           .    .    .     .    .    .     .   .  .   .        // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
             .    .    .           .    .    .     .    .    .     .   .  .   .        // _M_assign_aux.
             .    .    .           .    .    .     .    .    .     .   .  .   .        void
             .    .    .           .    .    .     .    .    .     .   .  .   .        _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
-- line 1654 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/ricbit/work/knuth/dlx/cover_mrv.cc
--------------------------------------------------------------------------------
            Ir I1mr ILmr            Dr D1mr DLmr            Dw D1mw DLmw            Bc         Bcm Bi Bim 

-- line 3 ----------------------------------------
             .    .    .             .    .    .             .    .    .             .           .  .   .  #include <string>
             .    .    .             .    .    .             .    .    .             .           .  .   .  #include <sstream>
             .    .    .             .    .    .             .    .    .             .           .  .   .  #include <unordered_map>
             .    .    .             .    .    .             .    .    .             .           .  .   .  #include <set>
             .    .    .             .    .    .             .    .    .             .           .  .   .  #include <fstream>
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .  using namespace std;
             .    .    .             .    .    .             .    .    .             .           .  .   .  
           945    0    0           420   27    0           420    0    0             0           0  0   0  struct Header {
             .    .    .             .    .    .             .    .    .             .           .  .   .    string name;
             .    .    .             .    .    .             .    .    .             .           .  .   .    int llink;
             .    .    .             .    .    .             .    .    .             .           .  .   .    int rlink;
             .    .    .             .    .    .             .    .    .             .           .  .   .  };
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .  struct Node {
             .    .    .             .    .    .             .    .    .             .           .  .   .    int top;
             .    .    .             .    .    .             .    .    .             .           .  .   .    int ulink;
             .    .    .             .    .    .             .    .    .             .           .  .   .    int dlink;
             .    .    .             .    .    .             .    .    .             .           .  .   .  };
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .  class Graph {
             .    .    .             .    .    .             .    .    .             .           .  .   .   public:
             .    .    .             .    .    .             .    .    .             .           .  .   .    Graph(const vector<Header>& header, const vector<Node>& nodes)
             .    .    .             .    .    .             .    .    .             .           .  .   .        : last_header(begin(header), end(header)), 
             1    0    0             0    0    0             1    0    0             0           0  0   0          last_nodes(begin(nodes), end(nodes)), frame(0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void graph(const vector<Header>& header, const vector<Node>& nodes) {
             .    .    .             .    .    .             .    .    .             .           .  .   .      ostringstream oss;
             .    .    .             .    .    .             .    .    .             .           .  .   .      //cout << "creating frame " << frame << "\n";
             .    .    .             .    .    .             .    .    .             .           .  .   .      oss << "frame" << frame++ << ".dot";
             .    .    .             .    .    .             .    .    .             .           .  .   .      ofstream ofs;
             .    .    .             .    .    .             .    .    .             .           .  .   .      ofs.open(oss.str());
-- line 35 ----------------------------------------
-- line 79 ----------------------------------------
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .      ofs << "] ;\n";
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Header> last_header;
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Node> last_nodes;
             .    .    .             .    .    .             .    .    .             .           .  .   .    int frame;
             .    .    .             .    .    .             .    .    .             .           .  .   .  };
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             7    0    0             3    0    0             3    0    0             0           0  0   0  class ExactCover {
             .    .    .             .    .    .             .    .    .             .           .  .   .   public:
            14    2    2             1    0    0             8    0    0             0           0  0   0    ExactCover(
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<string>& items,
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<vector<string>>& options)
             .    .    .             .    .    .             .    .    .             .           .  .   .        : header(build_header(items)), nodes(build_nodes(items, options)),
             .    .    .             .    .    .             .    .    .             .           .  .   .          solution(options.size()), graph(header, nodes) {
            11    0    0             9    3    0             0    0    0             1           0  0   0    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void print() {
             .    .    .             .    .    .             .    .    .             .           .  .   .      cout << "nodes " << nodes.size() << "\n";
             .    .    .             .    .    .             .    .    .             .           .  .   .      auto print_line = [&](int j, int size, auto func) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        for (int i = j * 8; i < j * 8 + 8 && i < size; i++) {
             .    .    .             .    .    .             .    .    .             .           .  .   .          cout << func(i) << "\t";
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .        cout << "\n";
-- line 102 ----------------------------------------
-- line 115 ----------------------------------------
             .    .    .             .    .    .             .    .    .             .           .  .   .        cout << "\n";
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void write_dot() {
             .    .    .             .    .    .             .    .    .             .           .  .   .      graph.graph(header, nodes);
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             6    0    0             0    0    0             6    0    0             0           0  0   0    int run() {
             1    0    0             0    0    0             1    0    0             0           0  0   0      int count = 0;
             .    .    .             .    .    .             .    .    .             .           .  .   .      int p, i, value;
             .    .    .             .    .    .             .    .    .             .           .  .   .    //d1:
             1    0    0             0    0    0             0    0    0             0           0  0   0      int l = 0;
             .    .    .             .    .    .             .    .    .             .           .  .   .    d2:
   791,393,632    1    1   263,797,878    2    0             0    0    0   263,797,877   2,279,465  0   0      if (header[0].rlink == 0) {
     2,279,184    0    0     2,279,184    0    0             0    0    0             0           0  0   0        count++;
             .    .    .             .    .    .             .    .    .             .           .  .   .        goto d8;
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    //d3:
             .    .    .             .    .    .             .    .    .             .           .  .   .      i = header[0].rlink;
   784,556,079    1    1   523,037,386    1    0             0    0    0             0           0  0   0      value = nodes[i].top;
31,397,321,230    1    1 7,686,250,217   65    0             0    0    0 7,470,323,851 220,351,689  0   0      for (int p = header[i].rlink; p != 0; p = header[p].rlink) {
29,008,507,412    0    0 7,252,126,853   20    0             0    0    0 7,252,126,853 286,680,926  0   0        if (nodes[p].top < value) {
             .    .    .             .    .    .             .    .    .             .           .  .   .          i = p;
             .    .    .             .    .    .             .    .    .             .           .  .   .          value = nodes[p].top;
   980,946,986    0    0             0    0    0             0    0    0   266,897,594  49,193,951  0   0          if (value == 0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .            break;
             .    .    .             .    .    .             .    .    .             .           .  .   .          }
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    //d4:
             .    .    .             .    .    .             .    .    .             .           .  .   .      cover(i);
   523,037,386    0    0             0    0    0   261,518,693    4    0             0           0  0   0      solution[l] = nodes[i].dlink;
             .    .    .             .    .    .             .    .    .             .           .  .   .    d5:
 1,257,812,359    0    0             0    0    0             0    0    0   525,316,569  48,239,100  0   0      if (solution[l] == i) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        goto d7;
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
   525,316,569    0    0             0    0    0             0    0    0             0           0  0   0      p = solution[l] + 1;
 2,165,691,896    0    0             0    0    0             0    0    0 1,082,845,948 178,740,539  0   0      while (p != solution[l]) {
 2,165,691,896    1    1 1,082,845,948    0    0             0    0    0             0           0  0   0        int j = nodes[p].top;
 2,165,691,896    0    0             0    0    0             0    0    0 1,082,845,948 240,783,903  0   0        if (j <= 0) {
   263,797,876    0    0   263,797,876    0    0             0    0    0             0           0  0   0          p = nodes[p].ulink;
             .    .    .             .    .    .             .    .    .             .           .  .   .        } else {
             .    .    .             .    .    .             .    .    .             .           .  .   .          cover(j);
 1,638,096,144    0    0   819,048,072    0    0             0    0    0             0           0  0   0          p++;
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
   263,797,876    0    0             0    0    0             0    0    0             0           0  0   0      l++;
             .    .    .             .    .    .             .    .    .             .           .  .   .      goto d2;
             .    .    .             .    .    .             .    .    .             .           .  .   .    d6:
   527,595,752    1    1             0    0    0             0    0    0             0           0  0   0      p = solution[l] - 1;
 7,024,671,440    0    0 1,346,643,824    0    0             0    0    0 1,082,845,948 150,043,814  0   0      while (p != solution[l]) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        int j = nodes[p].top;
 2,165,691,896    1    1             0    0    0             0    0    0 1,082,845,948 101,711,793  0   0        if (j <= 0) {
   263,797,876    0    0   263,797,876    0    0             0    0    0             0           0  0   0          p = nodes[p].dlink;
             .    .    .             .    .    .             .    .    .             .           .  .   .        } else {
             .    .    .             .    .    .             .    .    .             .           .  .   .          uncover(j);
 2,457,144,216    1    1   819,048,072    0    0             0    0    0             0           0  0   0          p--;
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .      i = nodes[solution[l]].top;
   527,595,752    0    0   263,797,876    0    0   263,797,876    0    0             0           0  0   0      solution[l] = nodes[solution[l]].dlink;
   437,084,656    1    1    43,321,695    0    0             0    0    0             0           0  0   0      goto d5;
             .    .    .             .    .    .             .    .    .             .           .  .   .    d7:
             .    .    .             .    .    .             .    .    .             .           .  .   .      uncover(i);
             .    .    .             .    .    .             .    .    .             .           .  .   .    d8:
   527,595,754    1    1             0    0    0             0    0    0   263,797,877          11  0   0      if (l == 0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        return count;
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
   263,797,876    0    0             0    0    0             0    0    0             0           0  0   0      l--;
 1,846,585,132    0    0   791,393,628    0    0             0    0    0   263,797,876          16  0   0      if (nodes[solution[l]].top == 0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        goto d5;
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .      goto d6;
             8    0    0             8    0    0             0    0    0             0           0  0   0    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .   private:
             .    .    .             .    .    .             .    .    .             .           .  .   .     void dump_current() {
             .    .    .             .    .    .             .    .    .             .           .  .   .      cout << "items remaining: ";
             .    .    .             .    .    .             .    .    .             .           .  .   .      for (int t = 0; header[t].rlink != 0;) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        t = header[t].rlink;
             .    .    .             .    .    .             .    .    .             .           .  .   .        cout << header[t].name << " ";
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
-- line 197 ----------------------------------------
-- line 220 ----------------------------------------
             .    .    .             .    .    .             .    .    .             .           .  .   .      for (p = p + 1; nodes[p].top > 0; p++) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        cout << header[nodes[p].top].name << " ";
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    int count_nodes(
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<string>& items,
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<vector<string>>& options) {
             1    0    0             0    0    0             0    0    0             0           0  0   0      int total_nodes = 2 + items.size();
           574    1    1             3    0    0             0    0    0           285          10  0   0      for (const auto& option : options) {
           284    0    0             0    0    0             0    0    0             0           0  0   0        total_nodes += 1 + option.size();
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .      return total_nodes;
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Header> build_header(
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<string>& items) {
             1    0    0             1    0    0             0    0    0             0           0  0   0      vector<Header> header(items.size() + 1);
             2    0    0             0    0    0             1    0    0             0           0  0   0      int size = items.size();
           217    1    1           105    0    0             3    0    0           106           1  0   0      for (int i = 0; i <= size; i++) {
           210    1    1             0    0    0             0    0    0           105           3  0   0        if (i == 0) {
             6    1    1             2    0    0             2    0    0             0           0  0   0          header[i] = { "", size, 1 };
             .    .    .             .    .    .             .    .    .             .           .  .   .        } else {
           627    0    0           104    0    0           209    0    0             0           0  0   0          header[i] = { items[i - 1], i - 1, (i + 1) % (size + 1) };
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .      return header;
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Node> build_nodes(
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<string>& items,
             .    .    .             .    .    .             .    .    .             .           .  .   .        const vector<vector<string>>& options) {
             1    0    0             0    0    0             0    0    0             0           0  0   0      vector<Node> nodes(count_nodes(items, options));
             .    .    .             .    .    .             .    .    .             .           .  .   .      vector<int> last(items.size() + 1);
             .    .    .             .    .    .             .    .    .             .           .  .   .      unordered_map<string, int> name;
           316    0    0           104    0    0             0    0    0           105          12  0   0      for (int i = 1; i <= int(items.size()); i++) {
           312    0    0             0    0    0           312   11    0             0           0  0   0        nodes[i] = {0, i, i};
           104    0    0             0    0    0           104    0    0             0           0  0   0        last[i] = i;
           104    0    0             0    0    0           104    0    0             0           0  0   0        name[items[i - 1]] = i;
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             1    0    0             0    0    0             0    0    0             0           0  0   0      int current = items.size() + 1;
             2    0    0             0    0    0             0    0    0             0           0  0   0      int lastspacer = -2;
             .    .    .             .    .    .             .    .    .             .           .  .   .      int spacer = current;
         1,528    1    1             3    0    0             0    0    0           285           1  0   0      for (int i = 0; i < int(options.size()); i++) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        spacer = current;
         1,136    0    0             0    0    0           284    0    0             0           0  0   0        nodes[spacer].top = -i;
         1,136    0    0             0    0    0           284   34    0             0           0  0   0        nodes[spacer].ulink = lastspacer + 1;
           568    0    0             0    0    0           284    0    0             0           0  0   0        nodes[spacer].dlink = spacer + options[i].size();
             .    .    .             .    .    .             .    .    .             .           .  .   .        lastspacer = spacer;
           568    0    0             0    0    0           284    0    0             0           0  0   0        current++;
         8,476    1    1         4,404    0    0           568    0    0         1,468         213  0   0        for (int j = 0; j < int(options[i].size()); j++) {
         2,368    0    0         1,184    0    0             0    0    0             0           0  0   0          int item = name[options[i][j]];
         2,368    0    0         2,368    3    0             0    0    0             0           0  0   0          nodes[item].top++;
         4,736    0    0         2,368    0    0         1,184   19    0             0           0  0   0          nodes[last[item]].dlink = current;
         1,184    0    0             0    0    0         1,184    1    0             0           0  0   0          nodes[item].ulink = current;
         1,184    0    0             0    0    0         1,184   90    0             0           0  0   0          nodes[current].top = item;
         4,736    0    0         1,184    0    0         2,368    0    0             0           0  0   0          nodes[current].ulink = last[item];
         1,184    0    0             0    0    0         1,184  143    0             0           0  0   0          nodes[current].dlink = item;
         1,184    0    0             0    0    0         1,184    0    0             0           0  0   0          last[item] = current;
         1,184    0    0             0    0    0             0    0    0             0           0  0   0          current++;
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             3    0    0             0    0    0             1    0    0             0           0  0   0      nodes[current].top = -int(options.size());
             2    0    0             1    0    0             1    0    0             0           0  0   0      nodes[current].ulink = lastspacer + 1;
             1    0    0             0    0    0             1    0    0             0           0  0   0      nodes[current].dlink = -1;
             .    .    .             .    .    .             .    .    .             .           .  .   .      return nodes;
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void cover(int i) {
11,104,696,972    0    0 2,967,243,069    0    0             0    0    0 2,760,063,848 314,444,908  0   0      for (auto p = nodes[i].dlink; p != i; p = nodes[p].dlink) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        hide(p);
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
 2,161,133,530    1    1 1,080,566,765    0    0             0    0    0             0           0  0   0      auto l = header[i].llink;
   819,048,072    0    0   819,048,072    0    0             0    0    0             0           0  0   0      auto r = header[i].rlink;
 2,161,133,530    0    0             0    0    0 1,080,566,765    0    0             0           0  0   0      header[l].rlink = r;
 2,161,133,530    0    0             0    0    0 1,080,566,765    0    0             0           0  0   0      header[r].llink = l;
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void uncover(int i) {
 1,080,566,765    0    0             0    0    0             0    0    0             0           0  0   0      auto l = header[i].llink;
 1,080,566,765    1    1 1,080,566,765    0    0             0    0    0             0           0  0   0      auto r = header[i].rlink;
 3,241,700,295    0    0 1,080,566,765    0    0 1,080,566,765    0    0             0           0  0   0      header[l].rlink = i;
 2,161,133,530    1    1             0    0    0 1,080,566,765    0    0             0           0  0   0      header[r].llink = i;
10,671,006,975    0    0 2,760,063,848    0    0             0    0    0 2,760,063,848 744,168,473  0   0      for (auto p = nodes[i].ulink; p != i; p = nodes[p].ulink) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        unhide(p);
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void hide(int p) {
14,830,745,513    3    3             0    0    0             0    0    0 6,575,624,215 721,463,121  0   0      for (auto q = p + 1; q != p;) {
13,151,248,430    0    0 6,575,624,215   43    0             0    0    0             0           0  0   0        auto x = nodes[q].top;
 7,467,598,281    0    0 6,575,624,215    1    0             0    0    0             0           0  0   0        auto u = nodes[q].ulink;
 6,575,624,215    0    0 6,575,624,215    3    0             0    0    0             0           0  0   0        auto d = nodes[q].dlink;
15,933,131,601    2    2             0    0    0             0    0    0 6,575,624,215 498,302,276  0   0        if (x <= 0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .          q = u;
             .    .    .             .    .    .             .    .    .             .           .  .   .        } else {
14,688,381,396    1    1             0    0    0 4,896,127,132   35    0             0           0  0   0          nodes[u].dlink = d;
 9,792,254,264    0    0             0    0    0 4,896,127,132  117    0             0           0  0   0          nodes[d].ulink = u;
 4,896,127,132    0    0 4,896,127,132    0    0             0    0    0             0           0  0   0          nodes[x].top--;
 4,896,127,132    0    0             0    0    0             0    0    0             0           0  0   0          q++;
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    void unhide(int p) {
14,830,745,513    0    0             0    0    0             0    0    0 6,575,624,215 671,926,824  0   0      for (auto q = p - 1; q != p;) {
13,151,248,430    1    1 6,575,624,215    0    0             0    0    0             0           0  0   0        auto x = nodes[q].top;
 6,575,624,215    0    0 6,575,624,215    0    0             0    0    0             0           0  0   0        auto u = nodes[q].ulink;
 7,736,810,570    0    0 6,575,624,215    0    0             0    0    0             0           0  0   0        auto d = nodes[q].dlink;
16,800,442,200    0    0             0    0    0             0    0    0 6,575,624,215 389,304,105  0   0        if (x <= 0) {
             .    .    .             .    .    .             .    .    .             .           .  .   .          q = d;
             .    .    .             .    .    .             .    .    .             .           .  .   .        } else {
 9,792,254,264    0    0             0    0    0 4,896,127,132    0    0             0           0  0   0          nodes[u].dlink = q;
 9,792,254,264    0    0             0    0    0 4,896,127,132    0    0             0           0  0   0          nodes[d].ulink = q;
 4,896,127,132    0    0 4,896,127,132    0    0             0    0    0             0           0  0   0          nodes[x].top++;
 4,896,127,132    0    0             0    0    0             0    0    0             0           0  0   0          q--;
             .    .    .             .    .    .             .    .    .             .           .  .   .        }
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Header> header;
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<Node> nodes;
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<int> solution;
             .    .    .             .    .    .             .    .    .             .           .  .   .    Graph graph;
             .    .    .             .    .    .             .    .    .             .           .  .   .  };
             .    .    .             .    .    .             .    .    .             .           .  .   .  
         3,420    2    2           285    0    0         1,995    0    0             0           0  0   0  vector<string> parse_line(const string& line) {
             .    .    .             .    .    .             .    .    .             .           .  .   .    istringstream iss(line);
             .    .    .             .    .    .             .    .    .             .           .  .   .    vector<string> items;
             .    .    .             .    .    .             .    .    .             .           .  .   .    string item;
         9,438    2    2         3,146    0    0         1,573    0    0         1,573           6  0   0    while (iss >> item) {
             .    .    .             .    .    .             .    .    .             .           .  .   .      items.push_back(item);
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             .    .    .             .    .    .             .    .    .             .           .  .   .    return items;
         3,420    0    0         2,565    0    0             0    0    0           285           2  0   0  }
             .    .    .             .    .    .             .    .    .             .           .  .   .  
            10    2    2             1    0    0             7    0    0             0           0  0   0  int main() {
             .    .    .             .    .    .             .    .    .             .           .  .   .    string line;
             .    .    .             .    .    .             .    .    .             .           .  .   .    getline(cin, line);
             6    1    1             0    0    0             3    0    0             0           0  0   0    vector<string> items = parse_line(line);
             2    0    0             0    0    0             1    0    0             0           0  0   0    vector<vector<string>> options;
           855    0    0           570    0    0             0    0    0           285           1  0   0    while (getline(cin, line)) {
           855    0    0           284    0    0           285    0    0             0           0  0   0      vector<string> option = parse_line(line);
           568    0    0           284    0    0             0    0    0           284           0  0   0      if (!option.empty()) {
             .    .    .             .    .    .             .    .    .             .           .  .   .        options.push_back(option);
             .    .    .             .    .    .             .    .    .             .           .  .   .      }
             .    .    .             .    .    .             .    .    .             .           .  .   .    }
             9    1    1             2    0    0             2    0    0             0           0  0   0    ExactCover ec(items, options);
             .    .    .             .    .    .             .    .    .             .           .  .   .    //ec.print();
             .    .    .             .    .    .             .    .    .             .           .  .   .    //ec.write_dot();
             8    1    1             0    0    0             3    0    0             0           0  0   0    cout << "Number of solutions: " << ec.run() << "\n";
             .    .    .             .    .    .             .    .    .             .           .  .   .    return 0;
            14    1    1             9    1    0             0    0    0             1           0  0   0  }

--------------------------------------------------------------------------------
 Ir I1mr ILmr  Dr D1mr DLmr  Dw D1mw DLmw  Bc Bcm Bi Bim 
--------------------------------------------------------------------------------
100    2    3 100    2    0 100   16    9 100 100  0   0  percentage of events annotated

